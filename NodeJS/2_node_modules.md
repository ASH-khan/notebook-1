# 2 Node Modules

### Core Modules

Node has built-in modules that can aid in building an application. These modules do not need to be downloaded via npm (Node Package Manager).

We use _require()_ to load modules in Node.

Here is an example of the _path_ module:

```javascript
var path = require('path');

console.log(path.basename(__filename));

var dirUploads = path.join(__dirname, 'www', "uploads");

console.log(dirUploads);
// app.js
// ~/currentdir/www/uploads
```


We can use the _util_ module and its helper functions:

```javascript
var util = require('util');
// Adds timestamp to log
util.log("Hello World");
// 26 Oct 15:54:21 - Hello World
```


The _v8_ module can give us information about memory:

```javascript
var util = require("util");
var v8 = require("v8");

util.log(v8.getHeapStatistics());
// 26 Oct 15:54:21 - { total_heap_size: 92743,
// total_heap_size_executable: 4192234,
// ...
// heap_size_limit: 124209383
//}
```

-----

### Collecting Information with Readline

_Readline_ is a module that allows us to ask questions of our terminal user. It is a wrapper around the stdin and stdout objects that allows us to easily ask users questions and save those answers:

```javascript
var readline = require("readline");

var realPerson = {
  name: '',
  sayings: []
};

// Set up i.o for rl interface
var rl = readline.createInterface(process.stdin, process.stdout);

// Add question which waits for user input and passes
// answer to callback
rl.question("What is the name of a real person? ", function(answer) {
  // Set answer
  realPerson.name = answer;
  // Set up next question
  rl.setPrompt(`What would ${realPerson.name} say? `);

  // Display the prompt
  rl.prompt()

  // Set up a listener every time user uses newline
  rl.on('line', function(saying) {
    // If 'exit' exit rl.close
    if (saying === 'exit') {
      // Close readline
      rl.close();
    }

    // Set prompt one last time
    rl.setPrompt(`What else would ${realPerson.name} say? ('exit' to leave) `);
    rl.prompt();
    // Push sayings to
    realPerson.sayings.push(saying);
  });
});

// Set listener on 'close' for rl
rl.on('close', function() {
  // format for string and json that will be placed accordingly
  console.log("%s is a real person that says %j", realPerson.name, realPerson.sayings);
  // end process
  process.exit();
});
```

And we run our app:

```
$ node app

What is the name of a real person? Elvis Presley
What would Elvis Presley say? Oh baby
What else would Elvis Presley say> ('exit' to leave) Hey there...
What else would Elvis Presley say> ('exit' to leave) exit
Elvis is a real person that says ["Oh baby", "Hey there..."]
```

-----

### Handling Events with EventEmitter

Node's implementation of the pub/sub design pattern, in which we can create listeners for and create custom events:

```javascript
var events = require("events");
// new instance of EventEmitter constructor
var emitter = new events.EventEmitter();
// create custom event
emitter.on("customEvent", function(message, status) {
  console.log(`${status}: ${message}`);
});
// emit customEvent passing in message and status
emitter.emit("customEvent", "Hello World", 200);
```
```
$ node app

200: Hello World
```

Using the _util_ module we can combine functionality with _events_ module:

```javascript
var EventEmitter = require("events").EventEmitter;
var util = require('util');

var Person = function(name) {
  this.name = name;
};

// Using util module's inherits we set Person constructor
// to inherit the EventEmitter constructor
util.inherits(Person, EventEmitter);

var ben = new Person("Ben");

// custom 'speak' event
ben.on("speaks", function(said) {
  console.log(`${this.name}: ${said}`);
});

// emit speak event
ben.emit("speak", "You may delay, but time will not.");
```

Run the app:

```
$ node app

Ben: You may delay, but time will not.
```

-----

### Exporting Custom Modules

We can export custom modules that can then be _required_ accordingly using _modules.export_:

```javascript
var Person = function() {
  this.name = name;
};

// We export the Person
module.exports = Person;
```

We can then _require_ it in another module:

```javascript
var Person = require("./path/to/module") // do not need '.js'

// Use the imported module
var George = new Person ("George");
```

-----

### Creating Child Process with Exec

The _child process_ module lets you execute external processes in your environment. In other words, your Node app can communicate with other applications on the computer it is hosted:

```javascript
// require the child_process exec method
var exec = require("child_process").exec;

// Runs the bash/unix command when app runs
// any data returned injects into callback
exec("ls", function(err, stdout) {
  if (err) {
    throw err;
  }
  console.log("Listing Finished\n");
  console.log("stdout");
});
```

Run the app:

```
$ node app

Listing Finished

app.js
file.txt
otherfile.md
```

-----

### Creating Child Process with Spawn

_Spawn_ functions much like _exec_, but _spawn_ is made for long running processes with large amounts of data:

```javascript
// require the child_process exec method
var spawn = require("child_process").spawn;
// set up spawn with the command to run in terminal
// followed by array of options after command.
var cp = spawn("ping", ["-c", "4", "http://google.com"]);

// Listen for data events on the stdout
cp.stdout.on("data", function(data){
  console.log(`STDOUT: ${data.toString()}`);
});

// Listen for close event on child process
cp.on("close", function() {
  console.log("\nChild Process has ended");
  process.exit();
});
```

Run the app:

```
$ node app

64 bytes from 8.8.8.8: icmp_seq=0 ttl=57 time=23.845 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=57 time=22.067 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=57 time=18.079 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=57 time=23.284 ms

Child Process has ended
```
